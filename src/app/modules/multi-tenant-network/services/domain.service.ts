import { Injectable, OnDestroy } from '@angular/core';
import {
  BehaviorSubject,
  Observable,
  Subscription,
  catchError,
  map,
  of,
  shareReplay,
  take,
  tap,
} from 'rxjs';
import {
  CreateMultiTenantDomainGQL,
  CreateMultiTenantDomainMutation,
  CreateMultiTenantDomainMutationVariables,
  CustomHostnameStatusEnum,
  DnsRecordEnum,
  GetMultiTenantDomainGQL,
  GetMultiTenantDomainQuery,
} from '../../../../graphql/generated.engine';
import { ApolloQueryResult } from '@apollo/client';
import {
  MultiTenantDomainStatus,
  ReturnedMultiTenantDomain,
} from '../admin-console/tabs/domain/domain.types';

/**
 * Service for fetching and updating multi-tenant network domains.
 */
@Injectable({ providedIn: 'root' })
export class MultiTenantDomainService implements OnDestroy {
  /** Subject to store domain values. */
  public readonly domain$: BehaviorSubject<
    ReturnedMultiTenantDomain
  > = new BehaviorSubject<ReturnedMultiTenantDomain>(null);

  /** Subject to store whether domain has been loaded. */
  public readonly inProgress$: BehaviorSubject<boolean> = new BehaviorSubject<
    boolean
  >(false);

  /** Subject to store whether domain has been fetched at least once. */
  public readonly init$: BehaviorSubject<boolean> = new BehaviorSubject<
    boolean
  >(false);

  private domainFetchSubscription: Subscription;

  /**
   * Map the response status to one of our predefined display statuses
   */
  public readonly status$ = this.domain$.pipe(
    map(domain => {
      if (!domain || !domain?.status) {
        return MultiTenantDomainStatus.AUTOGENERATED;
      } else {
        switch (domain.status) {
          case CustomHostnameStatusEnum.Active:
          case CustomHostnameStatusEnum.TestActive:
          case CustomHostnameStatusEnum.TestActiveApex:
            return MultiTenantDomainStatus.ACTIVE;
          case CustomHostnameStatusEnum.Deleted:
          case CustomHostnameStatusEnum.Blocked:
          case CustomHostnameStatusEnum.TestBlocked:
          case CustomHostnameStatusEnum.TestFailed:
            return MultiTenantDomainStatus.FAILED;
          case CustomHostnameStatusEnum.Pending:
          case CustomHostnameStatusEnum.PendingBlocked:
          case CustomHostnameStatusEnum.PendingDeletion:
          case CustomHostnameStatusEnum.PendingMigration:
          case CustomHostnameStatusEnum.PendingProvisioned:
          case CustomHostnameStatusEnum.TestPending:
          case CustomHostnameStatusEnum.ActiveRedeploying:
          case CustomHostnameStatusEnum.Moved:
          case CustomHostnameStatusEnum.Provisioned:
          default:
            return MultiTenantDomainStatus.PENDING;
        }
      }
    }),
    shareReplay()
  );

  public readonly isAutogenerated$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.AUTOGENERATED;
    })
  );

  public readonly isActive$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.ACTIVE;
    })
  );

  public readonly isPending$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.PENDING;
    })
  );

  public readonly isFailed$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.FAILED;
    })
  );

  constructor(
    private getMultiTenantDomainGQL: GetMultiTenantDomainGQL,
    private createMultiTenantDomainGQL: CreateMultiTenantDomainGQL
  ) {}

  ngOnDestroy(): void {
    this.domainFetchSubscription?.unsubscribe();
  }

  /**
   * Fetches domain from server
   */
  public fetchDomain(): void {
    this.domainFetchSubscription = this.getDomain().subscribe(
      (domain: ReturnedMultiTenantDomain): void => {
        this.domain$.next(domain);
        this.init$.next(true);
      }
    );
  }

  /**
   * Gets domain from server.
   * @returns { Observable<ReturnedMultiTenantDomain | null> } domain from server.
   */
  public getDomain(): Observable<ReturnedMultiTenantDomain | null> {
    return this.getMultiTenantDomainGQL
      .fetch(null, {
        fetchPolicy: 'network-only',
      })
      .pipe(
        take(1),
        tap(() => {
          this.inProgress$.next(true);
        }),
        map((result: ApolloQueryResult<GetMultiTenantDomainQuery>) => {
          return result?.data?.multiTenantDomain ?? null;
        }),
        tap(() => {
          this.inProgress$.next(false);
        }),
        catchError(
          (e: unknown): Observable<null> => {
            return of(null);
          }
        )
      );
  }

  /**
   * Updates domain on server
   * @returns { Observable<boolean> } true if domain was updated.
   */
  public updateDomain(
    values: CreateMultiTenantDomainMutationVariables
  ): Observable<boolean> {
    return this.createMultiTenantDomainGQL.mutate(values).pipe(
      take(1),
      map((result: ApolloQueryResult<CreateMultiTenantDomainMutation>) => {
        this.domain$.next(result?.data?.createMultiTenantDomain);
        return Boolean(result?.data?.createMultiTenantDomain);
      }),
      catchError(
        (e: unknown): Observable<boolean> => {
          console.error(e);
          return of(false);
        }
      )
    );
  }
}
