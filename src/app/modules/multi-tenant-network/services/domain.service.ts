import { Injectable, OnDestroy } from '@angular/core';
import {
  BehaviorSubject,
  Observable,
  Subscription,
  catchError,
  map,
  of,
  take,
  tap,
} from 'rxjs';
import {
  CreateMultiTenantDomainGQL,
  CreateMultiTenantDomainMutation,
  CreateMultiTenantDomainMutationVariables,
  CustomHostnameStatusEnum,
  DnsRecordEnum,
  GetMultiTenantDomainGQL,
  GetMultiTenantDomainQuery,
} from '../../../../graphql/generated.engine';
import { ApolloQueryResult } from '@apollo/client';
import {
  MultiTenantDomainStatus,
  ReturnedMultiTenantDomain,
} from '../admin-console/tabs/domain/domain.types';
import { ToasterService } from '../../../common/services/toaster.service';

const ojmFakeData: ReturnedMultiTenantDomain = {
  domain: 'mortynet.kramnorth.com',
  dnsRecord: {
    name: 'mortynet.kramnorth.com',
    type: DnsRecordEnum.Cname,
    value: 'networks.minds.com',
  },
  status: CustomHostnameStatusEnum.Pending,
  ownershipVerificationDnsRecord: {
    name: '_cf-custom-hostname.mortynet.kramnorth.com',
    type: DnsRecordEnum.Txt,
    value: 'deeb89f4-9912-4c77-9e78-cb4dbfe9b6d2',
  },
};

/**
 * Service for fetching and updating multi-tenant network domains.
 */
@Injectable()
export class MultiTenantDomainService implements OnDestroy {
  /** Subject to store domain values. */
  public readonly domain$: BehaviorSubject<
    ReturnedMultiTenantDomain
  > = new BehaviorSubject<ReturnedMultiTenantDomain>(null);

  /** Subject to store whether domain has been loaded. */
  public readonly inProgress$: BehaviorSubject<boolean> = new BehaviorSubject<
    boolean
  >(false); // ojm true

  private subscriptions: Subscription[] = [];

  private domainFetchSubscription: Subscription;

  public readonly status$ = this.domain$.pipe(
    map(domain => {
      if (!domain || !domain?.status) {
        return MultiTenantDomainStatus.AUTOGENERATED;
      } else {
        switch (domain.status) {
          case CustomHostnameStatusEnum.Active:
          case CustomHostnameStatusEnum.TestActive:
          case CustomHostnameStatusEnum.TestActiveApex:
            return MultiTenantDomainStatus.ACTIVE;
          case CustomHostnameStatusEnum.Deleted:
          case CustomHostnameStatusEnum.Blocked:
          case CustomHostnameStatusEnum.TestBlocked:
          case CustomHostnameStatusEnum.TestFailed:
            return MultiTenantDomainStatus.FAILED;
          case CustomHostnameStatusEnum.Pending:
          case CustomHostnameStatusEnum.PendingBlocked:
          case CustomHostnameStatusEnum.PendingDeletion:
          case CustomHostnameStatusEnum.PendingMigration:
          case CustomHostnameStatusEnum.PendingProvisioned:
          case CustomHostnameStatusEnum.TestPending:
          case CustomHostnameStatusEnum.ActiveRedeploying:
          case CustomHostnameStatusEnum.Moved:

          case CustomHostnameStatusEnum.Provisioned:
          default:
            return MultiTenantDomainStatus.PENDING;
        }
      }
    })
  );

  constructor(
    private getMultiTenantDomainGQL: GetMultiTenantDomainGQL,
    private createMultiTenantDomainGQL: CreateMultiTenantDomainGQL,
    private toaster: ToasterService
  ) {}

  ngOnDestroy(): void {
    for (let subscription of this.subscriptions) {
      subscription.unsubscribe();
    }
    this.domainFetchSubscription?.unsubscribe();
  }

  /**
   * Fetches domain from server
   * ojm --- and updates local state.
   * @returns { void }
   */
  public fetchDomain(): void {
    if (this.domainFetchSubscription) {
      console.warn(
        'A request to load multi-tenant domain is already in progress'
      );
      return;
    }
    // ojm remove
    this.inProgress$.next(false);
    this.domain$.next(ojmFakeData);
    console.log('ojm fetchdomain', this.domain$.getValue());

    this.domainFetchSubscription = this.getDomain().subscribe(
      (domain: ReturnedMultiTenantDomain): void => {
        this.inProgress$.next(false);
        this.domain$.next(domain);
      }
    );
  }

  /**
   * Updates domain on server and local state.
   * @returns { Observable<boolean> } true if domain was updated.
   */
  public updateDomain(
    values: CreateMultiTenantDomainMutationVariables
  ): Observable<boolean> {
    return this.createMultiTenantDomainGQL.mutate(values).pipe(
      take(1),
      map((result: ApolloQueryResult<CreateMultiTenantDomainMutation>) => {
        // ojm handle when the response comes back with a ownershipVerificationDnsRecord. If it DOES, then we need to get a TXT record as well. store the unverifiedDomain$ temporarily here as well.
        this.domain$.next(result?.data?.createMultiTenantDomain);
        return Boolean(result?.data?.createMultiTenantDomain);
      }),
      tap((success: boolean): void => {
        if (success) {
          this.toaster.success('Custom domain has been saved');
        }
      }),
      catchError(
        (e: unknown): Observable<boolean> => {
          console.error(e);
          return of(false);
        }
      )
    );
  }

  // ojm todo
  // public verifyDomain?

  /**
   * Gets domain from server.
   * @returns { Observable<ReturnedMultiTenantDomain | null> } domain from server.
   */
  private getDomain(): Observable<ReturnedMultiTenantDomain | null> {
    return this.getMultiTenantDomainGQL
      .fetch(null, {
        fetchPolicy: 'no-cache',
      })
      .pipe(
        take(1),
        map((result: ApolloQueryResult<GetMultiTenantDomainQuery>) => {
          return result?.data?.multiTenantDomain ?? null;
        }),
        tap((domain: ReturnedMultiTenantDomain | null): void => {
          if (domain) {
            // ojm do something?
          }
        })
        // ojm what exactly does the AUTOGENERATED response look like? do i do it inside the catcherror?
      );
  }
}
