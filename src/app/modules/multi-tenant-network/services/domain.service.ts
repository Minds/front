import { Injectable, OnDestroy } from '@angular/core';
import {
  BehaviorSubject,
  Observable,
  Subscription,
  map,
  of,
  take,
  tap,
} from 'rxjs';
import {
  CreateMultiTenantDomainGQL,
  CreateMultiTenantDomainMutationVariables,
  CustomHostnameStatusEnum,
  DnsRecordEnum,
  GetMultiTenantDomainGQL,
  GetMultiTenantDomainQuery,
} from '../../../../graphql/generated.engine';
import { ApolloQueryResult } from '@apollo/client';
import {
  MultiTenantDomainStatus,
  ReturnedMultiTenantDomain,
} from '../admin-console/tabs/domain/domain.types';

export const ojmFakeData1: ReturnedMultiTenantDomain = {
  domain: 'mortynet.kramnorth.com',
  dnsRecord: {
    name: 'mortynet.kramnorth.com',
    type: DnsRecordEnum.Cname,
    value: 'networks.minds.com',
  },
  status: CustomHostnameStatusEnum.Pending,
  ownershipVerificationDnsRecord: {
    name: '_cf-custom-hostname.mortynet.kramnorth.com',
    type: DnsRecordEnum.Txt,
    value: 'deeb89f4-9912-4c77-9e78-cb4dbfe9b6d2',
  },
};

export const ojmFakeData2: ReturnedMultiTenantDomain = {
  domain: 'mortynet2.kramnorth.com',
  dnsRecord: {
    name: 'mortynet2.kramnorth.com',
    type: DnsRecordEnum.Cname,
    value: 'networks.minds.com',
  },
  status: CustomHostnameStatusEnum.Active,
  ownershipVerificationDnsRecord: {
    name: '_cf-custom-hostname.mortynet.kramnorth.com',
    type: DnsRecordEnum.Txt,
    value: 'deeb89f4-9912-4c77-9e78-cb4dbfe9b6d2',
  },
};

/**
 * Service for fetching and updating multi-tenant network domains.
 */
@Injectable({ providedIn: 'root' })
export class MultiTenantDomainService implements OnDestroy {
  /** Subject to store domain values. */
  public readonly domain$: BehaviorSubject<
    ReturnedMultiTenantDomain
  > = new BehaviorSubject<ReturnedMultiTenantDomain>(null);

  /** Subject to store whether domain has been loaded. */
  public readonly inProgress$: BehaviorSubject<boolean> = new BehaviorSubject<
    boolean
  >(false); // ojm set to true

  private domainFetchSubscription: Subscription;

  public readonly status$ = this.domain$.pipe(
    map(domain => {
      if (!domain || !domain?.status) {
        return MultiTenantDomainStatus.AUTOGENERATED;
      } else {
        switch (domain.status) {
          case CustomHostnameStatusEnum.Active:
          case CustomHostnameStatusEnum.TestActive:
          case CustomHostnameStatusEnum.TestActiveApex:
            return MultiTenantDomainStatus.ACTIVE;
          case CustomHostnameStatusEnum.Deleted:
          case CustomHostnameStatusEnum.Blocked:
          case CustomHostnameStatusEnum.TestBlocked:
          case CustomHostnameStatusEnum.TestFailed:
            return MultiTenantDomainStatus.FAILED;
          case CustomHostnameStatusEnum.Pending:
          case CustomHostnameStatusEnum.PendingBlocked:
          case CustomHostnameStatusEnum.PendingDeletion:
          case CustomHostnameStatusEnum.PendingMigration:
          case CustomHostnameStatusEnum.PendingProvisioned:
          case CustomHostnameStatusEnum.TestPending:
          case CustomHostnameStatusEnum.ActiveRedeploying:
          case CustomHostnameStatusEnum.Moved:
          case CustomHostnameStatusEnum.Provisioned:
          default:
            return MultiTenantDomainStatus.PENDING;
        }
      }
    })
  );

  public readonly isAutogenerated$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.AUTOGENERATED;
    })
  );

  public readonly isActive$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.ACTIVE;
    })
  );

  public readonly isPending$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.PENDING;
    })
  );

  public readonly isFailed$ = this.status$.pipe(
    map(status => {
      return status === MultiTenantDomainStatus.FAILED;
    })
  );

  constructor(
    private getMultiTenantDomainGQL: GetMultiTenantDomainGQL,
    private createMultiTenantDomainGQL: CreateMultiTenantDomainGQL
  ) {}

  ngOnDestroy(): void {
    this.domainFetchSubscription?.unsubscribe();
  }

  /**
   * Fetches domain from server
   * @returns { void }
   */
  public fetchDomain(): void {
    if (this.domainFetchSubscription) {
      console.warn(
        'A request to load multi-tenant domain is already in progress'
      );
      return;
    }

    // ojm remove
    this.inProgress$.next(false);
    if (this.domain$.getValue()) {
      this.domain$.next(ojmFakeData1);
    } else {
      this.domain$.next(null);
    }
    console.log('ojm fetchdomain', this.domain$.getValue());

    this.domainFetchSubscription = this.getDomain().subscribe(
      (domain: ReturnedMultiTenantDomain): void => {
        this.inProgress$.next(false);
        this.domain$.next(domain);
      }
    );
  }

  /**
   * Gets domain from server.
   * @returns { Observable<ReturnedMultiTenantDomain | null> } domain from server.
   */
  public getDomain(): Observable<ReturnedMultiTenantDomain | null> {
    return this.getMultiTenantDomainGQL.fetch().pipe(
      take(1),
      map((result: ApolloQueryResult<GetMultiTenantDomainQuery>) => {
        return result?.data?.multiTenantDomain ?? null;
      }),
      tap(() => {
        this.domainFetchSubscription.unsubscribe();
      })
    );
  }

  /**
   * Updates domain on server
   * @returns { Observable<boolean> } true if domain was updated.
   */
  public updateDomain(
    values: CreateMultiTenantDomainMutationVariables
  ): Observable<boolean> {
    return of(true);

    // ojm uncomment
    // return this.createMultiTenantDomainGQL.mutate(values).pipe(
    //   take(1),
    //   map((result: ApolloQueryResult<CreateMultiTenantDomainMutation>) => {
    //     this.domain$.next(result?.data?.createMultiTenantDomain);
    //     return Boolean(result?.data?.createMultiTenantDomain);
    //   }),
    //   catchError(
    //     (e: unknown): Observable<boolean> => {
    //       console.error(e);
    //       return of(false);
    //     }
    //   )
    // );
  }
}
